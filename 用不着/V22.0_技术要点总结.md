# V22.0 技术要点总结 - 追问图片记忆机制

## 🎯 核心问题

### 问题1：为什么追问时AI会产生幻觉？

**错误理解**：
> "通义千问有多轮对话能力，第一次发送了图片，后面就记住了，不需要再发图片。"

**真相**：
> 通义千问的多轮对话**必须每次都包含图片**，它不会"记住"之前的图片！

**技术原理**：

```python
# ❌ 错误方式（V21.0及之前）
messages = [
    # 第一次：带图片
    {
        "role": "user",
        "content": [
            {"text": "请解答这道题"},
            {"image": "data:image/png;base64,..."} 
        ]
    },
    {"role": "assistant", "content": "..."},
    
    # 追问：只有文本，AI看不到图片！
    {
        "role": "user",
        "content": "那第二小题呢？"  # ❌ AI已经"忘记"图片了
    }
]
```

**为什么会产生幻觉**：
1. AI第一次回答时"看到"了图片
2. 追问时只收到文本："那第二小题呢？"
3. AI只能根据之前的**文字回答**来猜测题目内容
4. AI不知道图片里具体是什么题，只能编造 → **幻觉**

---

## ✅ 正确的多轮对话机制

### V22.0 的解决方案

**核心思想**：
> **每次追问都重新构建包含图片的完整对话历史**

**代码实现**：

```python
# ✅ 正确方式（V22.0）
def build_messages_with_image(session_id, new_prompt):
    # 1. 获取原始图片（从session保存的数据）
    original_image = SESSIONS[session_id]["image_base_64"]
    
    # 2. 获取对话历史
    history = SESSIONS[session_id]["history"]
    
    # 3. 重建第一条消息（用户首次提问 + 图片）
    first_message = {
        "role": "user",
        "content": [
            {"text": history[0]["content"]},  # 首次提问的文本
            {"image": f"data:image/png;base64,{original_image}"}  # ← 关键！
        ]
    }
    
    # 4. 构建完整消息列表
    messages = [first_message]  # 第一条带图片
    messages.extend(history[1:])  # 后续历史（AI回答、用户追问等）
    messages.append({"role": "user", "content": new_prompt})  # 当前追问
    
    return messages
```

**为什么这样能解决问题**：

```
【第一次提问】
messages = [
    {role: "user", content: [
        {text: "请解答这道题"},
        {image: "..."} ← AI能看到图片
    ]}
]
AI回答：基于图片内容回答 ✅

【第一次追问】
messages = [
    {role: "user", content: [
        {text: "请解答这道题"},
        {image: "..."} ← AI又能看到图片了！
    ]},
    {role: "assistant", content: "..."},
    {role: "user", content: "那第二小题呢？"}
]
AI回答：看着图片回答 ✅

【第二次追问】
messages = [
    {role: "user", content: [
        {text: "请解答这道题"},
        {image: "..."} ← AI还是能看到图片！
    ]},
    {role: "assistant", content: "..."},
    {role: "user", content: "那第二小题呢？"},
    {role: "assistant", content: "..."},
    {role: "user", content: "有其他解法吗？"}
]
AI回答：看着图片回答 ✅
```

**关键点**：
- ✅ 每次对话，第一条消息**都包含图片**
- ✅ AI始终能"看到"原始题目
- ✅ 不会产生幻觉或编造内容

---

## 📊 对话历史结构

### Session存储结构

```python
SESSIONS = {
    "session-id-123": {
        "image_base_64": "iVBORw0KGgoAAAANS...",  # ← 保存原始图片！
        "title": "新对话",
        "history": [
            {"role": "user", "content": "请解答这道题"},     # 注意：只存文本
            {"role": "assistant", "content": "这道题..."},
            {"role": "user", "content": "那第二小题呢？"},
            {"role": "assistant", "content": "第二小题..."}
        ]
    }
}
```

**为什么 `history` 只存文本，不存图片？**

1. **节省内存**：图片很大（几MB），只存一份在 `image_base_64`
2. **简化逻辑**：历史记录只关注对话内容
3. **动态重建**：需要时再把图片加到第一条消息

---

### 发送给AI的消息结构

```python
# 新会话（第一次提问）
messages_to_send = [
    {
        "role": "user",
        "content": [
            {"text": "题目内容如下：\n\n{OCR识别结果}\n\n【任务要求】\n请解答..."},
            {"image": "data:image/png;base64,..."}
        ]
    }
]

# 追问（第N次）
messages_to_send = [
    {
        "role": "user",
        "content": [
            {"text": "请解答这道题"},  # ← 首次提问的原始文本
            {"image": "data:image/png;base64,..."}  # ← 原始图片
        ]
    },
    {"role": "assistant", "content": "..."},
    {"role": "user", "content": "那第二小题呢？"},
    {"role": "assistant", "content": "..."},
    {"role": "user", "content": "有其他解法吗？"}  # ← 当前追问
]
```

**关键区别**：
- ❌ **不要**把OCR增强的Prompt放到历史里
- ✅ **要**保留用户原始提问（"请解答这道题"）
- ✅ **要**每次都加上图片

---

## 🔧 代码实现细节

### 新会话（首次提问）

```python
if is_new_session:
    # 1. OCR识别
    ocr_text = extract_text_with_pix2text(image)
    
    # 2. 构建增强Prompt（只用于这一次调用）
    enhanced_prompt = f"""题目内容如下：
    
{ocr_text}

【任务要求】
{request.prompt}

【重要说明】
你是一个专业的学科辅导AI助手...
"""
    
    # 3. 发送给AI（text + image）
    messages_to_send = [{
        "role": "user",
        "content": [
            {'text': enhanced_prompt},  # ← OCR增强版
            {'image': f"data:image/png;base64,{request.image_base_64}"}
        ]
    }]
    
    # 4. 保存到历史（只存原始提问，不存OCR）
    SESSIONS[session_id]["history"].append({
        "role": "user", 
        "content": request.prompt  # ← 只存"请解答这道题"
    })
```

**为什么历史不存OCR增强的Prompt？**
- OCR结果可能很长（几千字符）
- 后续追问不需要重复OCR内容
- AI已经从图片中"看到"了所有信息

---

### 追问（第N次）

```python
else:  # 追问
    # 1. 获取原始图片
    original_image_base64 = SESSIONS[session_id]["image_base_64"]
    
    # 2. 重建第一条消息（带图片）
    first_user_message = SESSIONS[session_id]["history"][0]
    messages_to_send = [{
        "role": "user",
        "content": [
            {'text': first_user_message["content"]},  # "请解答这道题"
            {'image': f"data:image/png;base64,{original_image_base64}"}
        ]
    }]
    
    # 3. 添加后续历史
    for msg in SESSIONS[session_id]["history"][1:]:
        messages_to_send.append(msg)
    
    # 4. 添加当前追问
    messages_to_send.append({"role": "user", "content": request.prompt})
```

**关键步骤**：
1. 取出原始图片（`image_base_64`）
2. 重建第一条消息（文本 + 图片）
3. 追加历史记录
4. 追加当前提问

---

## 🎯 常见误区

### 误区1：AI会"记住"图片

❌ **错误认知**：
> "第一次发了图片，AI就记住了，后面不需要再发。"

✅ **正确认知**：
> "通义千问的多模态对话，**每次请求都需要包含图片**，它不会持久化图片信息。"

**证据**：
- 官方文档要求每次都发图片
- 不发图片会导致幻觉（实测）

---

### 误区2：历史记录应该包含图片

❌ **错误做法**：
```python
# 把图片也存到历史里
SESSIONS[session_id]["history"].append({
    "role": "user",
    "content": [
        {"text": "请解答"},
        {"image": "data:image/png;base64,..."}  # ❌ 浪费内存
    ]
})
```

✅ **正确做法**：
```python
# 历史只存文本，图片单独保存
SESSIONS[session_id]["image_base_64"] = request.image_base_64  # ✅ 只存一份
SESSIONS[session_id]["history"].append({
    "role": "user",
    "content": "请解答"  # ✅ 只存文本
})
```

**原因**：
- 图片可能有几MB
- 多次保存会浪费内存
- 发送时动态重建即可

---

### 误区3：OCR增强Prompt应该保存到历史

❌ **错误做法**：
```python
# 把OCR增强的Prompt存到历史
enhanced_prompt = f"题目内容如下：\n\n{ocr_text}\n\n..."  # 几千字符
SESSIONS[session_id]["history"].append({
    "role": "user",
    "content": enhanced_prompt  # ❌ 历史会非常臃肿
})
```

✅ **正确做法**：
```python
# 只存原始提问
SESSIONS[session_id]["history"].append({
    "role": "user",
    "content": request.prompt  # ✅ "请解答这道题"（短小精悍）
})
```

**原因**：
- OCR结果可能几千字符
- 每次追问都会看到原始图片，不需要重复OCR文本
- 历史应该简洁，只存用户真实的对话

---

## 🚀 性能优化

### 1. 图片压缩（可选）

```python
def compress_image_base64(base64_str, max_size_kb=500):
    """压缩图片到指定大小，减少内存占用"""
    import io
    from PIL import Image
    import base64
    
    # 解码
    img_data = base64.b64decode(base64_str)
    img = Image.open(io.BytesIO(img_data))
    
    # 压缩
    quality = 85
    while True:
        buffer = io.BytesIO()
        img.save(buffer, format='JPEG', quality=quality)
        size_kb = len(buffer.getvalue()) / 1024
        
        if size_kb <= max_size_kb or quality <= 20:
            break
        quality -= 5
    
    # 编码
    return base64.b64encode(buffer.getvalue()).decode()
```

---

### 2. 会话清理（推荐）

```python
import time

# 定期清理过期会话
def clean_old_sessions(max_age_seconds=3600):
    """清理超过1小时未使用的会话"""
    current_time = time.time()
    to_delete = []
    
    for session_id, session_data in SESSIONS.items():
        if current_time - session_data.get('last_access', 0) > max_age_seconds:
            to_delete.append(session_id)
    
    for session_id in to_delete:
        del SESSIONS[session_id]
        print(f"[会话清理] 删除过期会话: {session_id}")
```

---

### 3. 内存监控

```python
import sys

def get_session_memory_usage(session_id):
    """查看单个会话的内存占用"""
    session = SESSIONS.get(session_id)
    if not session:
        return 0
    
    image_size = len(session.get('image_base_64', '')) / 1024 / 1024  # MB
    history_size = sys.getsizeof(str(session.get('history', []))) / 1024 / 1024  # MB
    
    print(f"[内存] 会话 {session_id[:8]}...")
    print(f"  图片: {image_size:.2f} MB")
    print(f"  历史: {history_size:.2f} MB")
    print(f"  总计: {image_size + history_size:.2f} MB")
    
    return image_size + history_size
```

---

## 📝 最佳实践

### 1. Session数据结构

```python
SESSIONS[session_id] = {
    "image_base_64": "...",          # 原始图片（只存一份）
    "title": "新对话",
    "history": [...],                 # 对话历史（只存文本）
    "created_at": time.time(),       # 创建时间
    "last_access": time.time(),      # 最后访问时间
    "ocr_cache": "...",              # OCR缓存（可选）
}
```

---

### 2. 日志输出规范

```python
# 新会话
print(f"\n{'='*60}")
print(f"创建新会话: {session_id}")
print(f"{'='*60}")

# 追问
print(f"\n{'='*60}")
print(f"继续会话: {session_id}")
print(f"[追问] 用户提问: {request.prompt[:50]}...")
print(f"[追问模式] 重新构建对话历史，包含原始图片...")
print(f"[追问模式] 对话历史重建完成，共 {len(messages_to_send)} 条消息（包含图片）")
print(f"{'='*60}")
```

---

### 3. 错误处理

```python
try:
    # 获取图片
    original_image_base64 = SESSIONS[session_id].get("image_base_64")
    
    if not original_image_base64:
        raise HTTPException(
            status_code=500, 
            detail="会话图片丢失，请重新开始对话"
        )
    
    # 重建消息...
    
except KeyError:
    raise HTTPException(
        status_code=404, 
        detail="会话不存在或已过期"
    )
```

---

## ✅ 总结

### V22.0 核心技术点

1. **图片持久化** ✅
   - 保存在 `SESSIONS[session_id]["image_base_64"]`
   - 每次追问时重新使用

2. **历史记录分离** ✅
   - 图片和历史分开存储
   - 历史只存文本，节省内存

3. **动态消息重建** ✅
   - 追问时重建第一条消息（文本 + 图片）
   - 确保AI每次都能看到图片

4. **OCR增强与历史的分离** ✅
   - OCR增强只用于首次调用
   - 历史只存用户原始提问

5. **删除后端自动续答** ✅
   - 简化后端逻辑
   - 由前端处理续答

---

**版本**: V22.0  
**核心改进**: 追问图片记忆机制  
**解决问题**: AI幻觉、遗忘图片  
**技术关键**: 每次追问都重新发送图片

